using Duality;
using Duality.Components;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Duality.Drawing;
using Duality.Resources;

namespace WorldSailorsDuality
{
    [RequiredComponent(typeof(HeightMap))]
    public class LandRendererShaded : Renderer,ICmpInitializable
    {
        public ContentRef<Material> LandMaterial { get; set; } = Material.DualityIcon;
        public HeightMap map{ get; set; }
        /// <summary>
        /// Look Up Table for Conversion of Height->Color
        /// (Heights part)
        /// </summary>
        public List<float> ColorLUTheights { get; set; } = new List<float>();
        /// <summary>
        /// Look Up Table for Conversion of Height->Color
        /// (Color part)
        /// </summary>
        public List<ColorRgba> ColorLUTColor { get; set; } = new List<ColorRgba>();
        /// <summary>
        /// Transition Height from SeaFloor Material to Beach Material
        /// </summary>
        public float MatTransitionSeaFloorBeach { get; set; } = -50;
        /// <summary>
        /// Transition Height from Beach Material to Land
        /// </summary>
        public float MatTransitionBeachLand { get; set; } = 25;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float LandTextHeightFactor { get; set; } = 10;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float LandTextScale { get; set; } = 25000;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float BeachTextHeightFactor { get; set; } = 7;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float BeachTextScale { get; set; } = 2000;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float SeaFloorTextHeightFactor { get; set; } = 3;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float SeaFloorTextScale { get; set; } = 50000;

        /// <summary>
        /// Screen gets split into Grid for Coloring/Texturing
        /// </summary>
        public int GridSizeX
        {
            get { return sizeX; }
            set { sizeX = value; InitArrays(); }
        }

        /// <summary>
        /// Screen gets split into Grid for Coloring/Texturing
        /// </summary>
        public int GridSizeY
        {
            get { return sizeY; }
            set { sizeY = value; InitArrays(); }
        }

        [DontSerialize]
        private VertexC1P3T4A1[] Vertices;
        [DontSerialize]
        private VertexC1P3T4A1[] Quads;
        [DontSerialize]
        private float spacingX;
        [DontSerialize]
        private float spacingY;
        [DontSerialize]
        private float width;
        [DontSerialize]
        private float height;

        private int sizeX = 100;
        private int sizeY = 100;
        /// <summary>
        /// This Holds a temporary Array of Heights Generated by GenerateMap
        /// </summary>
        [DontSerialize]
        private float[][] heights;

        public override float BoundRadius
        {
            get
            {
                return float.MaxValue;
            }
        }
              

        public override void Draw(IDrawDevice device)
        {
            //Find The right spot in the screen for our Verteces
            Vector3 TopLeftWorld = device.GetSpaceCoord(new Vector3(0, 0, 0));
            Vector3 BottomRightWorld = device.GetSpaceCoord(new Vector3(device.TargetSize.X, device.TargetSize.Y, 0));
            Vector3 WorldArea = (BottomRightWorld - TopLeftWorld);
            Vector3 WorldOffset = device.RefCoord - WorldArea / 2f;
            WorldOffset.Z = 0;
            //define Parameters Off Grid
            width = WorldArea.X;
            height = WorldArea.Y;
            spacingX = width / (sizeX - 1);
            spacingY = height / (sizeY - 1);
            //Generate Height Map
            map.GenerateMap(WorldOffset.Xy, new Vector2(spacingX, spacingY), ref heights);
            //Preprocess Coordinates
            float scaleTemp = 1f;
            Vector3 offsetFromCamera = WorldOffset;
            device.PreprocessCoords(ref offsetFromCamera, ref scaleTemp);
            //Create Grid of Vertices
            for (int x = 0; x < sizeX; x++)
            {
                for (int y = 0; y < sizeY; y++)
                {
                    Vertices[y * sizeX + x].Pos.X = offsetFromCamera.X + x * spacingX * scaleTemp;
                    Vertices[y * sizeX + x].Pos.Y = offsetFromCamera.Y + y * spacingY * scaleTemp;
                    Vertices[y * sizeX + x].Pos.Z = offsetFromCamera.Z - heights[x][y];
                    Vertices[y * sizeX + x].Color = getColorFromHeight(heights[x][y]);

                    Vector4 Taide = new Vector4();
                    Taide.X = (x * spacingX + WorldOffset.X);
                    Taide.Y = (y * spacingY + WorldOffset.Y);
                    Taide.Z = heights[x][y];
                    Taide.W = 25000;

                    Vertices[y * sizeX + x].TexCoord = Taide;
                    //Vertices[x][y].Attrib = heights[x][y];
                }
            }
            
            
            LandMaterial.Res.SetUniform("beachHeight", MatTransitionSeaFloorBeach);
            LandMaterial.Res.SetUniform("landHeight", MatTransitionBeachLand);

            for (int x = 0; x < sizeX - 1; x++)
            {
                for (int y = 0; y < sizeY - 1; y++)
                {
                    Quads[4 * (y * (sizeX - 1) + x) + 0] = Vertices[y * sizeX + x];
                    Quads[4 * (y * (sizeX - 1) + x) + 1] = Vertices[y * sizeX + x + 1];
                    Quads[4 * (y * (sizeX - 1) + x) + 2] = Vertices[(y + 1) * sizeX + x + 1];
                    Quads[4 * (y * (sizeX - 1) + x) + 3] = Vertices[(y + 1) * sizeX + x];
                }
            }

            device.AddVertices(LandMaterial, VertexMode.Quads, Quads);
                   
        }
        
        //Improve: Generate LUT at Frame start to save time
        private ColorRgba getColorFromHeight(float z)
        {
            if(ColorLUTColor == null || ColorLUTheights == null || ColorLUTColor.Count == 0 || ColorLUTheights.Count == 0)
                return ColorRgba.Red;

            //find last
            int last = ColorLUTheights.Count;
            if (ColorLUTColor.Count < last)
                last = ColorLUTColor.Count;
            last--;

            //Out of Bounds
            if (z < ColorLUTheights[0])
                return ColorLUTColor[0];
            if (z > ColorLUTheights[last])
                return ColorLUTColor[last];

            ColorRgba colorA = ColorLUTColor[0];
            ColorRgba colorB = ColorLUTColor[0];
            float biasA = 0;
            for (int n = 1; n <= last; n++)
            {
                if (ColorLUTheights[n] > z)
                {
                    colorA = ColorLUTColor[n];
                    colorB = ColorLUTColor[n - 1];
                    float disA = z - ColorLUTheights[n];
                    float disB = ColorLUTheights[n - 1] - z;
                    biasA = (disA) / (disA + disB);
                    break;
                }
            }
            return ColorRgba.Lerp(colorA, colorB, biasA);
        }

        #region Initialisation
        private void InitArrays()
        {
            if (sizeX <= 5)
                sizeX = 50;
            if (sizeY <= 5)
                sizeY = 50;


            if (sizeX > 1000)
                sizeX = 50;
            if (sizeY > 1000)
                sizeY = 50;

            heights = new float[sizeX][];
            for (int n = 0; n < sizeX; n++)
                heights[n] = new float[sizeY];

            spacingX = width / (sizeX - 1);
            spacingY = height / (sizeY - 1);

            Vertices = new VertexC1P3T4A1[sizeX*sizeY];
            Quads = new VertexC1P3T4A1[4 * (sizeX - 1) * (sizeY - 1)]; 
        }

        public void OnInit(InitContext context)
        {
            map = GameObj.GetComponent<HeightMap>();
            InitArrays();
        }

        public void OnShutdown(ShutdownContext context)
        {
        }
        #endregion
        
    }
}
