using Duality;
using Duality.Components;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Duality.Drawing;
using Duality.Resources;

namespace WorldSailorsDuality
{
    [RequiredComponent(typeof(HeightMap))]
    public class LandRenderer:Renderer,ICmpInitializable
    {
        public ContentRef<Duality.Resources.Material> MaterialWasser { get; set; } = Material.DualityIcon;
        public ContentRef<Duality.Resources.Material> MaterialStrand { get; set; } = Material.DualityIcon;
        public ContentRef<Duality.Resources.Material> MaterialLand { get; set; } = Material.DualityIcon;
        public HeightMap map{ get; set; }
        /// <summary>
        /// Look Up Table for Conversion of Height->Color
        /// (Heights part)
        /// </summary>
        public List<float> ColorLUTheights { get; set; } = new List<float>();
        /// <summary>
        /// Look Up Table for Conversion of Height->Color
        /// (Color part)
        /// </summary>
        public List<ColorRgba> ColorLUTColor { get; set; } = new List<ColorRgba>();
        /// <summary>
        /// Transition Height from SeaFloor Material to Beach Material
        /// </summary>
        public float MatTransitionSeaFloorBeach { get; set; } = -50;
        /// <summary>
        /// Transition Height from Beach Material to Land
        /// </summary>
        public float MatTransitionBeachLand { get; set; } = 25;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float LandTextHeightFactor { get; set; } = 10;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float LandTextScale { get; set; } = 25000;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float BeachTextHeightFactor { get; set; } = 7;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float BeachTextScale { get; set; } = 2000;
        /// <summary>
        /// Creates kind of a 3D effect
        /// </summary>
        public float SeaFloorTextHeightFactor { get; set; } = 3;
        /// <summary>
        /// scaling of Texture
        /// </summary>
        public float SeaFloorTextScale { get; set; } = 50000;

        /// <summary>
        /// Screen gets split into Grid for Coloring/Texturing
        /// </summary>
        public int GridSizeX
        {
            get { return sizeX; }
            set { sizeX = value; InitArrays(); }
        }

        /// <summary>
        /// Screen gets split into Grid for Coloring/Texturing
        /// </summary>
        public int GridSizeY
        {
            get { return sizeY; }
            set { sizeY = value; InitArrays(); }
        }

        [DontSerialize]
        private VertexC1P3T4A1[][] Vertices;
        [DontSerialize]
        private List<VertexC1P3T4A1[]> Quads;
        [DontSerialize]
        private float spacingX;
        [DontSerialize]
        private float spacingY;
        [DontSerialize]
        private float width;
        [DontSerialize]
        private float height;
        [DontSerialize]
        private int sizeX;
        [DontSerialize]
        private int sizeY;
        /// <summary>
        /// This Holds a temporary Array of Heights Generated by GenerateMap
        /// </summary>
        [DontSerialize]
        private float[][] heights;

        public override float BoundRadius
        {
            get
            {
                return float.MaxValue;
            }
        }
        
        //Creates a Vertex in the center of two Vertices
        private VertexC1P3T4A1 CreateMiddle(VertexC1P3T4A1 a, VertexC1P3T4A1 b)
        {
            VertexC1P3T4A1 ret = new VertexC1P3T4A1();
            ret.Pos = (a.Pos + b.Pos) / 2f;
            ret.Attrib = (a.Attrib + b.Attrib) / 2f;
            ret.Color = getColorFromHeight(ret.Attrib);
            ret.TexCoord = (a.TexCoord + b.TexCoord) / 2f;

            return ret;
        }

        //Splits Quad if it reachses From Land to sea level
        private List<VertexC1P3T4A1[]> SplitQuadRecursive(VertexC1P3T4A1[] q, int depth)
        {
            List<VertexC1P3T4A1[]> ret = new List<VertexC1P3T4A1[]>();
            bool reachesSea = false;
            bool reachesLand = false;
            foreach (VertexC1P3T4A1 vert in q)
            {
                if (vert.Attrib < 0)
                    reachesSea = true;
                if (vert.Attrib > MatTransitionBeachLand)
                    reachesLand = true;
            }

            if (reachesSea && reachesLand && depth > 0) //Split Quad into for
            {
                VertexC1P3T4A1 v1 = CreateMiddle(q[0], q[1]);
                VertexC1P3T4A1 v2 = CreateMiddle(q[0], q[3]);
                VertexC1P3T4A1 v3 = CreateMiddle(q[1], q[2]);
                VertexC1P3T4A1 v4 = CreateMiddle(q[3], q[2]);
                VertexC1P3T4A1 v5 = CreateMiddle(v2, v3);

                VertexC1P3T4A1[] q1 = new VertexC1P3T4A1[] { q[0], v1, v5, v2 };
                VertexC1P3T4A1[] q2 = new VertexC1P3T4A1[] { v1, q[1], v3, v5 };
                VertexC1P3T4A1[] q3 = new VertexC1P3T4A1[] { v5, v3, q[2], v4 };
                VertexC1P3T4A1[] q4 = new VertexC1P3T4A1[] { v2, v5, v4, q[3] };

                ret.AddRange(SplitQuadRecursive(q1, depth - 1));
                ret.AddRange(SplitQuadRecursive(q2, depth - 1));
                ret.AddRange(SplitQuadRecursive(q3, depth - 1));
                ret.AddRange(SplitQuadRecursive(q4, depth - 1));
            }
            else
                ret.Add(q);
            return ret;
        }

        public override void Draw(IDrawDevice device)
        {
            //Find The right spot in the screen for our Verteces
            Vector3 TopLeftWorld = device.GetSpaceCoord(new Vector3(0, 0, 0));
            Vector3 BottomRightWorld = device.GetSpaceCoord(new Vector3(device.TargetSize.X, device.TargetSize.Y, 0));
            Vector3 WorldArea = (BottomRightWorld - TopLeftWorld);
            Vector3 WorldOffset = device.RefCoord - WorldArea / 2f;
            WorldOffset.Z = 0;
            //define Parameters Off Grid
            width = WorldArea.X;
            height = WorldArea.Y;
            spacingX = width / (sizeX - 1);
            spacingY = height / (sizeY - 1);
            //Generate Height Map
            map.GenerateMap(WorldOffset.Xy, new Vector2(spacingX, spacingY),ref heights);
            //Preprocess Coordinates
            float scaleTemp = 1f;
            Vector3 offsetFromCamera = WorldOffset;
            device.PreprocessCoords(ref offsetFromCamera, ref scaleTemp);
            //Create Grid of Vertices
            for (int x = 0; x < sizeX; x++)
            {
                for (int y = 0; y < sizeY; y++)
                {
                    Vertices[x][y].Pos.X = offsetFromCamera.X + x * spacingX * scaleTemp;
                    Vertices[x][y].Pos.Y = offsetFromCamera.Y + y * spacingY * scaleTemp;
                    Vertices[x][y].Pos.Z = offsetFromCamera.Z - heights[x][y];
                    Vertices[x][y].Color = getColorFromHeight(heights[x][y]);

                    Vector4 Taide = new Vector4();
                    Taide.X = ((Vertices[x][y].Pos.X - offsetFromCamera.X) / scaleTemp + WorldOffset.X);
                    Taide.Y = ((Vertices[x][y].Pos.Y - offsetFromCamera.Y) / scaleTemp + WorldOffset.Y);
                    Taide.Z = 1;
                    Taide.W = 1;

                    Vertices[x][y].TexCoord = Taide;
                    Vertices[x][y].Attrib = heights[x][y];
                }
            }

            //Create Quads from Vertice Grid
            Quads = new List<VertexC1P3T4A1[]>();
            for (int x = 0; x < sizeX - 1; x++)
            {
                for (int y = 0; y < sizeY - 1; y++)
                {
                    VertexC1P3T4A1[] q = new VertexC1P3T4A1[4];
                    q[0] = Vertices[x][y];
                    q[1] = Vertices[x + 1][y];
                    q[2] = Vertices[x + 1][y + 1];
                    q[3] = Vertices[x][y + 1];
                    Quads.Add(q);
                }
            }

            List<VertexC1P3T4A1[]> QuadsSplit = new List<VertexC1P3T4A1[]>();

            //Refine Quad Array in Areas of interest
            foreach (VertexC1P3T4A1[] q in Quads)
            {
                QuadsSplit.AddRange(SplitQuadRecursive(q,3));
            }


                //Depending on Height choos Material
                //Special consideration on boundaries
                foreach (VertexC1P3T4A1[] q in QuadsSplit)
            {
                if (allVertecesGT(q, MatTransitionBeachLand))
                {
                    //Landquads
                    for (int n = 0; n < 4; n++)
                        q[n].TexCoord.W = q[n].Attrib * LandTextHeightFactor + LandTextScale;
                    device.AddVertices(MaterialLand, VertexMode.Quads, q);
                }
                else if (allVertecesGT(q, MatTransitionSeaFloorBeach) && allVertecesLT(q, MatTransitionBeachLand))
                {
                    //Strandquads
                    for (int n = 0; n < 4; n++)
                        q[n].TexCoord.W = q[n].Attrib * BeachTextHeightFactor + BeachTextScale;
                    device.AddVertices(MaterialStrand, VertexMode.Quads, q);
                }
                else if (allVertecesLT(q, MatTransitionSeaFloorBeach))
                {
                    //Meerquads
                    for (int n = 0; n < 4; n++)
                        q[n].TexCoord.W = q[n].Attrib * SeaFloorTextHeightFactor + SeaFloorTextScale;
                    device.AddVertices(MaterialWasser, VertexMode.Quads, q);
                }

                else if (allVertecesGT(q, MatTransitionSeaFloorBeach)) //Boundary Quad
                {
                    //Übergang LandStrand
                    VertexC1P3T4A1[] qe = new VertexC1P3T4A1[4];
                    for (int n = 0; n < 4; n++)
                    {
                        qe[n] = copyvertex(q[n]);
                        qe[n].Pos.Z = offsetFromCamera.Z - MatTransitionBeachLand;
                        q[n].TexCoord.W = q[n].Attrib * LandTextHeightFactor + LandTextScale;
                        qe[n].TexCoord.W = qe[n].Attrib * BeachTextHeightFactor + BeachTextScale;
                    }
                    device.AddVertices(MaterialLand, VertexMode.Quads, q);
                    device.AddVertices(MaterialStrand, VertexMode.Quads, qe);
                }
                else //Boundary Quad
                {
                    //Übergang Strand Meer
                    VertexC1P3T4A1[] qe = new VertexC1P3T4A1[4];
                    for (int n = 0; n < 4; n++)
                    {
                        qe[n] = copyvertex(q[n]);
                        qe[n].Pos.Z = offsetFromCamera.Z - MatTransitionSeaFloorBeach;
                        q[n].TexCoord.W = q[n].Attrib * BeachTextHeightFactor + BeachTextScale;
                        qe[n].TexCoord.W = qe[n].Attrib * SeaFloorTextHeightFactor + SeaFloorTextScale;
                    }
                    device.AddVertices(MaterialStrand, VertexMode.Quads, q);
                    device.AddVertices(MaterialWasser, VertexMode.Quads, qe);
                }

            }
        }
        
        //Improve: Generate LUT at Frame start to save time
        private ColorRgba getColorFromHeight(float z)
        {
            if(ColorLUTColor == null || ColorLUTheights == null || ColorLUTColor.Count == 0 || ColorLUTheights.Count == 0)
                return ColorRgba.Red;

            //find last
            int last = ColorLUTheights.Count;
            if (ColorLUTColor.Count < last)
                last = ColorLUTColor.Count;
            last--;

            //Out of Bounds
            if (z < ColorLUTheights[0])
                return ColorLUTColor[0];
            if (z > ColorLUTheights[last])
                return ColorLUTColor[last];

            ColorRgba colorA = ColorLUTColor[0];
            ColorRgba colorB = ColorLUTColor[0];
            float biasA = 0;
            for (int n = 1; n <= last; n++)
            {
                if (ColorLUTheights[n] > z)
                {
                    colorA = ColorLUTColor[n];
                    colorB = ColorLUTColor[n - 1];
                    float disA = z - ColorLUTheights[n];
                    float disB = ColorLUTheights[n - 1] - z;
                    biasA = (disA) / (disA + disB);
                    break;
                }
            }
            return ColorRgba.Lerp(colorA, colorB, biasA);
        }

        #region Initialisation
        private void InitArrays()
        {
            if (sizeX <= 5)
                sizeX = 50;
            if (sizeY <= 5)
                sizeY = 50;


            if (sizeX > 1000)
                sizeX = 50;
            if (sizeY > 1000)
                sizeY = 50;

            heights = new float[sizeX][];
            for (int n = 0; n < sizeX; n++)
                heights[n] = new float[sizeY];

            spacingX = width / (sizeX - 1);
            spacingY = height / (sizeY - 1);

            Vertices = new VertexC1P3T4A1[sizeX][];
            Quads = new List<VertexC1P3T4A1[]>();
            for (int n = 0; n < sizeX; n++)
                Vertices[n] = new VertexC1P3T4A1[sizeY];
        }

        public void OnInit(InitContext context)
        {
            map = GameObj.GetComponent<HeightMap>();
            InitArrays();

            // Backup Color LUT
            /*
            float minHeight = -1000;
            float maxHeight = 1000;
            float beachOffset = 100f;
            float deepOffset = 100;
            float center = (maxHeight + minHeight) / 2f;
            float LowLandoffset = center + beachOffset;
            float mountain = beachOffset * 2 + LowLandoffset;
            
            ColorRgba deepWater = new ColorHsva(237f / 360f, 1f, 0.43f).ToRgba();
            ColorRgba shallowWater = new ColorHsva(205f / 360f, 1f, 0.50f).ToRgba();
            ColorRgba waterline = new ColorHsva(201f / 360f, 1f, 0.97f).ToRgba();
            ColorRgba beach = new ColorHsva(040f / 360f, 0.5f, 0.60f).ToRgba();
            ColorRgba LowLand = new ColorHsva(118f / 360f, 1f, 0.50f).ToRgba();
            ColorRgba treeline = new ColorHsva(62f / 360f, 1f, 0.28f).ToRgba();
            ColorRgba highLand = new ColorHsva(62f / 360f, 0.2f, 0.38f).ToRgba();
            ColorRgba peaks = new ColorHsva(0f / 360f, 0f, 1f).ToRgba();

            ColorLUTheights= new List<float>();
            ColorLUTColor = new List<ColorRgba>();
            ColorLUTColor.Add(deepWater);
            ColorLUTheights.Add(minHeight);
            ColorLUTColor.Add(shallowWater);
            ColorLUTheights.Add(minHeight + deepOffset);
            ColorLUTColor.Add(waterline);
            ColorLUTheights.Add(center - beachOffset);
            ColorLUTColor.Add(beach);
            ColorLUTheights.Add(center);
            ColorLUTColor.Add(LowLand);
            ColorLUTheights.Add(center + beachOffset);
            ColorLUTColor.Add(treeline);
            ColorLUTheights.Add(mountain);
            ColorLUTColor.Add(highLand);
            ColorLUTheights.Add(maxHeight - deepOffset);
            ColorLUTColor.Add(peaks);
            ColorLUTheights.Add(maxHeight);
            */
        }

        public void OnShutdown(ShutdownContext context)
        {
        }
        #endregion

        #region Helpers
        private VertexC1P3T4A1 copyvertex(VertexC1P3T4A1 original)
        {
            VertexC1P3T4A1 qe = new VertexC1P3T4A1();
            qe.Pos.X = original.Pos.X;
            qe.Pos.Y = original.Pos.Y;
            qe.Pos.Z = original.Pos.Z;
            qe.TexCoord = original.TexCoord;
            qe.Attrib = original.Attrib;
            qe.Color = original.Color;
            return qe;
        }

        private bool allVertecesGT(VertexC1P3T4A1[] q, float limit)
        {
            for (int n = 0; n < 4; n++)
            {
                if (q[n].Attrib <= limit)
                    return false;
            }
            return true;
        }

        private bool allVertecesLT(VertexC1P3T4A1[] q, float limit)
        {
            for (int n = 0; n < 4; n++)
            {
                if (q[n].Attrib >= limit)
                    return false;
            }
            return true;
        }
        #endregion
    }
}
